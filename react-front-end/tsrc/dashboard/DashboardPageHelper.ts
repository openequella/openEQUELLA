/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0, (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  type Edge,
  extractClosestEdge,
} from "@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge";
import { DropTargetRecord } from "@atlaskit/pragmatic-drag-and-drop/types";
import * as OEQ from "@openequella/rest-api-client";
import { sequenceS } from "fp-ts/Apply";
import * as A from "fp-ts/Array";
import { flow, pipe } from "fp-ts/function";
import * as NEA from "fp-ts/NonEmptyArray";
import * as N from "fp-ts/number";
import * as O from "fp-ts/Option";
import * as Ord from "fp-ts/Ord";
import * as P from "fp-ts/Predicate";
import * as S from "fp-ts/string";
import * as TE from "fp-ts/TaskEither";
import { sprintf } from "sprintf-js";
import {
  PortletPosition,
  updatePortletPreference,
} from "../modules/DashboardModule";
import * as E from "../util/Either.extended";
import { languageStrings } from "../util/langstrings";
import {
  DndPortletData,
  DndPortletDataCodec,
} from "./components/DraggablePortlet";
import {
  DndColumnData,
  DndColumnDataCodec,
} from "./portlet/PortletDropZoneGrid";
import {
  isFirstColumnPortlet,
  portletFilterByColumn,
} from "./portlet/PortletHelper";

const { errors: dashboardErrors } = languageStrings.dashboard;

interface ValidDndDataResult {
  /**
   * The drag-and-drop data of the source portlet being moved.
   */
  sourceDndData: DndPortletData;
  /**
   * The drag-and-drop data of the target drop zone column or portlet.
   */
  targetDndData: DndPortletData | DndColumnData;
}

// Predicate to find a portlet by its UUID.
const isPortletByUuid = (
  targetUuid: string,
): P.Predicate<OEQ.Dashboard.BasicPortlet> =>
  pipe(
    (uuid: string) => S.Eq.equals(uuid, targetUuid),
    P.contramap((portlet) => portlet.commonDetails.uuid),
  );

/**
 * Validates and decodes the drag-and-drop data from the source and target.
 *
 * @param sourceDndData - The drag-and-drop data of the source portlet being moved.
 * @param targets -  The list of potential drop targets generated by the drag event.
 *                   Each target represents a valid drop zone and contains metadata describing
 *                   the DOM element and its associated data payload (such as column or portlet info)
 *                   used to determine where the dragged portlet should be placed.
 */
export const decodeDndData = (
  sourceDndData: Record<string, unknown>,
  targets: DropTargetRecord[],
): E.Either<string, ValidDndDataResult> => {
  const decodePortletDndData = () =>
    pipe(
      targets,
      A.findFirst((target) => DndPortletDataCodec.is(target.data)),
      O.fold(
        () => E.left("No portlet DnD target found."),
        (target) =>
          pipe(
            DndPortletDataCodec.decode(target.data),
            E.mapLeft(() => "Invalid portlet DnD data."),
          ),
      ),
    );

  const decodeColumnDndData = () =>
    pipe(
      targets,
      A.findFirst((target) => DndColumnDataCodec.is(target.data)),
      O.fold(
        () => E.left("No column DnD target found."),
        (target) =>
          pipe(
            DndColumnDataCodec.decode(target.data),
            E.mapLeft(() => "Invalid column DnD data."),
          ),
      ),
    );

  // Try to extract DND target data from the drop targets. First try portlet data, then column data.
  const decodeTargetDndData = () =>
    pipe(decodePortletDndData(), E.altW(decodeColumnDndData));

  const decodeSourceDndData = () =>
    pipe(
      DndPortletDataCodec.decode(sourceDndData),
      E.mapLeft(() => "Invalid source portlet DnD data."),
    );

  return sequenceS(E.Apply)({
    sourceDndData: decodeSourceDndData(),
    targetDndData: decodeTargetDndData(),
  });
};

// Get new portlet position when dropped onto a column drop zone.
const computeNewPositionForDndColumn = (
  originalDndData: DndPortletData,
  targetDndData: DndColumnData,
): PortletPosition => {
  const targetColumn = targetDndData.column;
  const targetCount = targetDndData.count;
  return {
    column: targetColumn,
    // Append to the end of the target column's portlet list.
    // When moving within the same column, subtract 1 because the source portlet
    // is already included in the column's count. For cross-column moves, use the full count.
    order:
      originalDndData.position.column === targetColumn
        ? targetCount - 1
        : targetCount,
  };
};

// Compute the portlet order when moving within the same column.
// If moving down the list (to a higher order), the new order needs to be decremented by 1
// because the original portlet is removed first before being re-inserted.
const computeNewOrderInSameColumn = (
  originalOrder: number,
  targetOrder: number,
) => (targetOrder > originalOrder ? targetOrder - 1 : targetOrder);

// Compute new portlet position when dropped onto another portlet.
const computeNewPositionForDndPortlet = (
  originalDndData: DndPortletData,
  targetDndData: DndPortletData,
  targetEdge: Edge | null,
): PortletPosition => {
  const { column: originalColumn, order: originalOrder } =
    originalDndData.position;
  const { column: targetColumn, order: rawTargetOrder } =
    targetDndData.position;

  // Based on the edge, compute the expected order, whether to insert before or after the target portlet.
  const dropAt = targetEdge === "bottom" ? rawTargetOrder + 1 : rawTargetOrder;
  // Compute the order based on whether it's a cross-column move or within the same column.
  const targetOrder =
    originalColumn !== targetColumn
      ? dropAt
      : computeNewOrderInSameColumn(originalOrder, dropAt);

  return {
    column: targetColumn,
    order: targetOrder,
  };
};

/**
 * Computes the new position for a portlet being dragged and dropped.
 * It handles both dropping onto a column drop zone and onto another portlet.
 *
 * @param sourceDndData - The drag-and-drop data of the source portlet being moved.
 * @param targetDndData - The drag-and-drop data of the target drop zone or portlet.
 * @returns Either an error message or the computed new portlet position.
 */
export const computeDndPortletNewPosition = ({
  sourceDndData,
  targetDndData,
}: ValidDndDataResult): E.Either<string, PortletPosition> => {
  const positionForDndColumn = DndColumnDataCodec.is(targetDndData)
    ? E.right(computeNewPositionForDndColumn(sourceDndData, targetDndData))
    : E.left("Drop zone is not a column");

  const positionForDndPortlet = DndPortletDataCodec.is(targetDndData)
    ? E.right(
        computeNewPositionForDndPortlet(
          sourceDndData,
          targetDndData,
          extractClosestEdge(targetDndData),
        ),
      )
    : E.left("Drop zone is not a portlet");

  return pipe(
    positionForDndPortlet,
    E.alt(() => positionForDndColumn),
    E.mapLeft(() => "Invalid target dnd data is provided."),
  );
};

/**
 * Updates a portlet's position with the given order and column.
 */
export const updatePortletPosition = (
  { order, column }: PortletPosition,
  portlet: OEQ.Dashboard.BasicPortlet,
): OEQ.Dashboard.BasicPortlet => ({
  ...portlet,
  commonDetails: {
    ...portlet.commonDetails,
    order,
    column,
  },
});

// Returns all portlets in the target drop column with new positions when a given portlet is moved to a new position.
const updatePortletsForNewPosition =
  (movedPortlet: OEQ.Dashboard.BasicPortlet, newPosition: PortletPosition) =>
  (
    dashboardDetails: OEQ.Dashboard.DashboardDetails,
  ): E.Either<string, OEQ.Dashboard.BasicPortlet[]> => {
    const allPortlets = dashboardDetails.portlets;

    // Get all portlets in the target(dropped) column ordered by their current 'order'.
    const getOrderedPortletsFromTargetColumn = () =>
      dashboardDetails.layout === "SingleColumn"
        ? [
            ...portletFilterByColumn(0)(allPortlets),
            ...portletFilterByColumn(1)(allPortlets),
          ]
        : portletFilterByColumn(newPosition.column)(allPortlets);

    // remove the moved portlet from the list.
    const removeMovedPortlet: (
      portlets: OEQ.Dashboard.BasicPortlet[],
    ) => OEQ.Dashboard.BasicPortlet[] = A.filter(
      (portlet) =>
        portlet.commonDetails.uuid !== movedPortlet.commonDetails.uuid,
    );

    // insert the moved portlet at its new order in the list.
    const insertMovedPortletAtNewOrder = (
      portlets: OEQ.Dashboard.BasicPortlet[],
    ) =>
      A.size(portlets) <= newPosition.order
        ? O.of(A.append(movedPortlet)(portlets))
        : A.insertAt(newPosition.order, movedPortlet)(portlets);

    // Produce a new ordered list of portlets after inserting the moved one.
    // The resulting list represents the final visual order in the target column, allowing each element’s index
    // to be used directly as its new `order` property.
    const reorderedPortlets = pipe(
      dashboardDetails.portlets,
      getOrderedPortletsFromTargetColumn,
      removeMovedPortlet,
      insertMovedPortletAtNewOrder,
      E.fromOption(
        () =>
          `Can't move portlet ${movedPortlet.commonDetails.name} to new position: ${newPosition}`,
      ),
    );

    // Update each portlet's position based on its new order(index) in the list.
    return pipe(
      reorderedPortlets,
      E.map(
        A.mapWithIndex((index, portlet) =>
          updatePortletPosition(
            { column: newPosition.column, order: index },
            portlet,
          ),
        ),
      ),
    );
  };

/**
 * Return a function that replaces portlets in the original list with the updated ones.
 *
 * @param originalPortlets The original list of portlets need to be replaced.
 */
const mergeWithOriginalPortlets =
  (originalPortlets: OEQ.Dashboard.BasicPortlet[]) =>
  (newPortlets: OEQ.Dashboard.BasicPortlet[]) => {
    // Get the new portlet by UUID or return the portlet itself if not found.
    const replaceWithNewPortlet = (
      originalPortlet: OEQ.Dashboard.BasicPortlet,
    ) =>
      pipe(
        newPortlets,
        A.findFirst(isPortletByUuid(originalPortlet.commonDetails.uuid)),
        O.getOrElse(() => originalPortlet),
      );

    return pipe(originalPortlets, A.map(replaceWithNewPortlet));
  };

/**
 * It returns a function that will build an updated list of portlets with new positions after moving a portlet.
 *
 * @param portlet - The portlet being moved.
 * @param newPosition - The new position of the portlet.
 */
export const movePortlet =
  (portlet: OEQ.Dashboard.BasicPortlet, newPosition: PortletPosition) =>
  (
    dashboardDetails: OEQ.Dashboard.DashboardDetails,
  ): E.Either<string, OEQ.Dashboard.BasicPortlet[]> =>
    pipe(
      dashboardDetails,
      updatePortletsForNewPosition(portlet, newPosition),
      E.map(mergeWithOriginalPortlets(dashboardDetails.portlets)),
    );

/**
 * Gets a list of portlets that have been moved by comparing their positions in the old and new lists.
 *
 * @param oldPortlets - The original list of portlets before the move.
 * @param newPortlets - The updated list of portlets after the move.
 */
export const getMovedPortlets = (
  oldPortlets: OEQ.Dashboard.BasicPortlet[],
  newPortlets: OEQ.Dashboard.BasicPortlet[],
): OEQ.Dashboard.BasicPortlet[] =>
  pipe(
    newPortlets,
    A.filter(
      ({ commonDetails: { uuid, order: newOrder, column: newColumn } }) =>
        pipe(
          oldPortlets,
          A.findFirst(isPortletByUuid(uuid)),
          O.match(
            () => false,
            ({ commonDetails: { column: oldColumn, order: oldOrder } }) =>
              oldColumn !== newColumn || oldOrder !== newOrder,
          ),
        ),
    ),
  );

/**
 * Updates dashboard’s portlets by applying a portlet update for the given UUID.
 * Safe to pass directly to a React state setter.
 *
 * @param uuid - UUID of the target portlet.
 * @param pref - Optional preferences to update in the targeted portlet. If not provided, the portlet will be removed.
 * @returns A function that takes dashboard details and returns the updated version.
 */
export const updateDashboardDetails =
  (uuid: string, pref?: OEQ.Dashboard.PortletPreference) =>
  (dashboard?: OEQ.Dashboard.DashboardDetails) => {
    if (!dashboard) {
      return dashboard;
    }

    const updateTargetPortlet = (portlet: OEQ.Dashboard.BasicPortlet) =>
      portlet.commonDetails.uuid === uuid
        ? {
            ...portlet,
            commonDetails: { ...portlet.commonDetails, ...pref },
          }
        : portlet;

    const filterOutTargetPortlet = (
      portlet: OEQ.Dashboard.BasicPortlet,
    ): boolean => portlet.commonDetails.uuid !== uuid;

    // Choose the operation based on whether pref is provided
    const updatedPortlets = pref
      ? pipe(dashboard.portlets, A.map(updateTargetPortlet)) // Update if pref exists
      : pipe(dashboard.portlets, A.filter(filterOutTargetPortlet)); // Filter if pref is missing

    return { ...dashboard, portlets: updatedPortlets };
  };

/**
 * Creates a TaskEither that wraps the updatePortletPreference API call.
 *
 * @param uuid UUID of the target portlet.
 * @param pref The new preferences to be applied to the portlet.
 * @returns A TaskEither that resolves to void on success or a formatted error message on failure.
 */
export const updatePortletPreferenceTE = (
  uuid: string,
  pref: OEQ.Dashboard.PortletPreference,
): TE.TaskEither<string, void> =>
  TE.tryCatch(
    () => updatePortletPreference(uuid, pref),
    (e) => sprintf(dashboardErrors.failedToUpdatePortletPref, `${e}`),
  );

/**
 * Computes the next order index for a portlet being restored into the first column.
 * - If dashboardDetails or the first-column list is empty, returns 0.
 * - Otherwise, finds the current max order in the first column and returns max + 1.
 *
 * @param dashboardDetails Optional current dashboard details.
 * @returns Next order number for a restored portlet.
 */
export const getOrderForRestoredPortlet = (
  dashboardDetails?: OEQ.Dashboard.DashboardDetails,
): number => {
  const byOrder = pipe(
    N.Ord,
    Ord.contramap((p: OEQ.Dashboard.BasicPortlet) => p.commonDetails.order),
  );

  const getNextOrder = (
    nea: NEA.NonEmptyArray<OEQ.Dashboard.BasicPortlet>,
  ): number => pipe(nea, NEA.max(byOrder), (p) => p.commonDetails.order + 1);

  return pipe(
    O.fromNullable(dashboardDetails),
    O.map((d) => d.portlets),
    O.chain(
      flow(A.filter(isFirstColumnPortlet), NEA.fromArray, O.map(getNextOrder)),
    ),
    O.getOrElse(() => 0),
  );
};
