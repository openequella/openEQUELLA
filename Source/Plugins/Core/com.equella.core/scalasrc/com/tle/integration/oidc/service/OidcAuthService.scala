/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0, (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.tle.integration.oidc.service

import cats.implicits._
import com.auth0.jwt.interfaces.DecodedJWT
import com.tle.common.institution.CurrentInstitution
import com.tle.common.usermanagement.user.valuebean.DefaultUserBean
import com.tle.common.usermanagement.user.{DefaultUserState, WebAuthenticationDetails}
import com.tle.core.guice.Bind
import com.tle.core.httpclient.sttpBackend
import com.tle.core.services.user.UserService
import com.tle.integration.jwk.JwkProvider
import com.tle.integration.jwt.decodeJwt
import com.tle.integration.oauth2.error.OAuth2Error
import com.tle.integration.oauth2.error.authorisation.{
  AccessDenied,
  AuthorisationError,
  InvalidState,
  NotAuthorized,
  InvalidRequest => AuthInvalidRequest
}
import com.tle.integration.oauth2.error.general.{GeneralError, InvalidJWT, ServerError}
import com.tle.integration.oauth2.error.token.{TokenError, TokenErrorResponse}
import com.tle.integration.oauth2.generatePKCEPair
import com.tle.integration.oidc.idp.{
  IdentityProviderDetails,
  IdentityProviderPlatform,
  RoleConfiguration
}
import com.tle.integration.oidc.{
  OpenIDConnectParams,
  getClaim,
  getClaimAsSet,
  getRequiredClaim,
  verifyIdToken => verifyToken
}
import com.tle.integration.util.{NO_FURTHER_INFO, getParam}
import io.circe.Error
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.parser._
import org.apache.http.client.utils.URIBuilder
import org.slf4j.LoggerFactory
import sttp.client.circe.asJson
import sttp.client.{DeserializationError, HttpError, ResponseError, UriContext, basicRequest}

import javax.inject.{Inject, Singleton}
import scala.jdk.CollectionConverters._
import scala.util.{Failure, Success, Try}

/** Structure for the response of a successful ID token request as per section 3.1.3.3 of the OIDC
  * spec as well as section 5.1 of OAuth2 spec.
  */
final case class OidcTokenResponse(
    access_token: String,
    id_token: String,
    refresh_token: Option[String],
    scope: Option[String],
    token_type: String,
    expires_in: Int
)

object OidcTokenResponse {
  implicit val tokenResponseEncoder = deriveEncoder[OidcTokenResponse]
  implicit val tokenResponseDecoder = deriveDecoder[OidcTokenResponse]
}

/** Structure for a successful verification of a callback request.
  *
  * @param code
  *   Authorisation code generated by a authorisation server and can be used once only.
  * @param state
  *   The state previously generated when OEQ initiated the authentication request.
  * @param stateDetails
  *   Details of the authentication request from which the state was generated.
  */
final case class OidcCallbackDetails(code: String, state: String, stateDetails: OidcStateDetails)

/** Service providing functions required in an OIDC authentication process.
  */
@Bind
@Singleton
class OidcAuthService @Inject() (
    stateService: OidcStateService,
    userService: UserService,
    oidcConfigurationService: OidcConfigurationService,
    jwkProvider: JwkProvider
)(implicit val nonceService: OidcNonceService) {
  private val RESPONSE_TYPE         = "code"
  private val GRANT_TYPE            = "authorization_code"
  private val SCOPE                 = "openid profile email"
  private val CODE_CHALLENGE_METHOD = "S256"

  private val LOGGER = LoggerFactory.getLogger(classOf[OidcAuthService])

  /** Retrieve an enabled Identity Provider configuration. Missing the configuration or having a
    * disabled one will result in an error of 'server_error'.
    */
  def getIdentityProvider: Either[ServerError, IdentityProviderDetails] =
    oidcConfigurationService.get
      .filterOrElse(_.commonDetails.enabled, ServerError("Identity Provider is not enabled"))
      .leftMap(_ => ServerError("Unable to retrieve Identity Provider configuration"))

  /** Based on section 3.1.2.1 of the OIDC spec and section 4.3 of the PKCE spec, build an
    * authentication URL with the following parameters to request end-user to be authenticated by
    * their configured Identity Provider.
    *
    *   - `scope` which must contain `openid`, but we also include `email` and `profile` in order to
    *     access users' email and profile information (e.g. family name) for creating a valid user
    *     state after the authentication
    *   - `response_type` which must be `code`
    *   - `redirect_uri` which points to the OEQ endpoint `oidclogin.do`
    *   - `client_id` which is the auth client ID configured in the OIDC configuration
    *   - `state` and `nonce` which are not required but we include them as the best practice
    *   - `code_challenge` and `code_challenge_method` required by PKCE
    *
    * @param authUrl
    *   OAuth2 authorisation endpoint of the selected Identity Provider
    * @param clientId
    *   ID of an OAuth2 client registered in the selected Identity Provider
    * @param targetPage
    *   The OEQ page which the user attempted to access before the login process
    */
  def buildAuthUrl(authUrl: String, clientId: String, targetPage: String): String = {
    val (codeVerifier, codeChallenge) = generatePKCEPair
    val stateDetails = OidcStateDetails(
      codeVerifier = codeVerifier,
      codeChallenge = codeChallenge,
      targetPage = Option(targetPage).filter(_.nonEmpty)
    )
    val state = stateService.createState(stateDetails)
    val nonce = nonceService.createNonce(state)

    val uriBuilder = new URIBuilder(authUrl)
      .addParameter(OpenIDConnectParams.CLIENT_ID, clientId)
      .addParameter(OpenIDConnectParams.RESPONSE_TYPE, RESPONSE_TYPE)
      .addParameter(OpenIDConnectParams.REDIRECT_URI, redirectUri)
      .addParameter(OpenIDConnectParams.SCOPE, SCOPE)
      .addParameter(OpenIDConnectParams.STATE, state)
      .addParameter(OpenIDConnectParams.NONCE, nonce)
      .addParameter(OpenIDConnectParams.CODE_CHALLENGE, codeChallenge)
      .addParameter(OpenIDConnectParams.CODE_CHALLENGE_METHOD, CODE_CHALLENGE_METHOD)

    uriBuilder.build().toString
  }

  /** According to section 4.1.2 of the OAuth2 spec, the callback request MUST contain the parameter
    * of 'code'. And because we always add 'state' in the initial request, the callback request MUST
    * also contain the parameter of 'state', and state must be validated before requesting a token.
    * Missing either param or failing the state verification results in an error of
    * 'invalid_request'.
    *
    * @param params
    *   The list of params from the callback request
    * @return
    *   Either an error of 'invalid_request' or the details of callback request
    */
  def verifyCallbackRequest(
      params: Map[String, Array[String]]
  ): Either[AuthorisationError, OidcCallbackDetails] = {
    def paramMap = getParam(params)
    def paramValue(p: String) =
      paramMap(p).toRight(AuthInvalidRequest(s"Missing required parameter '$p'"))

    for {
      code  <- paramValue(OpenIDConnectParams.CODE)
      state <- paramValue(OpenIDConnectParams.STATE)
      stateDetails <- stateService
        .getState(state)
        .toRight(InvalidState(s"Invalid state provided: $state"))
    } yield OidcCallbackDetails(code, state, stateDetails)
  }

  /** According to section 3.1.3.1 of the OIDC spec and section 4.5 of the PKCE spec, a Token
    * Request must contain the following parameters:
    *
    * `grant_type` which must be `authorization_code` `code` which is the authorisation code
    * received from the previous callback request `redirect_uri` which points to OEQ endpoint
    * `oidclogin.do` `client_id` which is the auth client ID configured in the OIDC configuration
    * `code_verifier` which will be verified by the authorisation server with the previously sent
    * `code_challenge`
    *
    * @param code
    *   Authorisation Code received from the previous callback request
    * @param stateDetails
    *   Details of the state where the code verifier is stored
    * @param idp
    *   Configuration of the selected Identity Provider that provides essential information for
    *   building the token request
    * @return
    *   Either an ID token issued by the Identity Provider or an error describing why the request
    *   failed
    */
  def requestIdToken(
      code: String,
      stateDetails: OidcStateDetails,
      idp: IdentityProviderDetails
  ): Either[OAuth2Error, String] = {
    val idpDetails = idp.commonDetails
    val tokenRequest = basicRequest
      .body(
        OpenIDConnectParams.CLIENT_ID     -> idpDetails.authCodeClientId,
        OpenIDConnectParams.CLIENT_SECRET -> idpDetails.authCodeClientSecret,
        OpenIDConnectParams.CODE          -> code,
        OpenIDConnectParams.CODE_VERIFIER -> stateDetails.codeVerifier,
        OpenIDConnectParams.GRANT_TYPE    -> GRANT_TYPE,
        OpenIDConnectParams.REDIRECT_URI  -> redirectUri
      )
      .post(uri"${idpDetails.tokenUrl}")
      .response(asJson[OidcTokenResponse])

    // Catch the potential network level errors thrown from sttp backend. Protocol level errors will be handled by 'handleTokenError'.
    Try {
      sttpBackend
        .flatMap(implicit backend => tokenRequest.send())
        .map(_.body)
        .unsafeRunSync()
        .leftMap(handleTokenError)
        .map(_.id_token)
    } match {
      case Success(result) => result
      case Failure(err) =>
        Left(ServerError(s"Failed to communicate with the Token endpoint: ${err.getMessage}"))
    }
  }

  /** Given a raw ID token and a previously built `state`, decode the token and then verify it as
    * per section 3.1.3.7 of the OIDC spec.
    *
    * @param token
    *   A freshly received ID token in raw string format
    * @param state
    *   Previously built state to assist in nonce verification
    * @param idp
    *   Configuration of the selected Identity Provider that provides essential information for the
    *   verification
    *
    * @return
    *   Either a verified and decoded ID token or an error describing why the verification failed
    */
  def verifyIdToken(
      token: String,
      state: String,
      idp: IdentityProviderDetails
  ): Either[GeneralError, DecodedJWT] =
    for {
      decodedToken <- decodeJwt(token)
      idpDetails = idp.commonDetails
      jsonWebKeySetProvider <- jwkProvider.get(idpDetails.keysetUrl)
      jwk <- Either
        .catchNonFatal(jsonWebKeySetProvider.get(decodedToken.getKeyId))
        .leftMap(_ => InvalidJWT("Failed to retrieve JWK by the obtained ID token's key ID"))
      verifiedToken <- verifyToken(
        decodedToken,
        idpDetails.issuer,
        idpDetails.authCodeClientId,
        jwk,
        state
      )
    } yield verifiedToken

  /** Log the user in with a UserState built based on the supplied ID token and the OIDC
    * configuration.
    *
    * If there is a custom username claim, attempt to retrieve a username from the ID token with
    * this claim, and failing to do so will result in an error of InvalidJWT; otherwise use the
    * claim `sub` as the username.
    *
    * If there is a role configuration, attempt to retrieve OEQ roles from the configured role
    * mappings with the ID token's custom role claim, or use the list of default roles.
    *
    * If family name and given name are absent in the ID token, default to empty strings.
    *
    * @param idToken
    *   ID token which must have been verified
    * @param wad
    *   The details of the HTTP request for this authentication attempt
    * @param idp
    *   OIDC Configuration which may have custom username claim and role configuration
    */
  def login(
      idToken: DecodedJWT,
      wad: WebAuthenticationDetails,
      idp: IdentityProviderDetails
  ): Either[GeneralError, Unit] = {
    def claim: String => Option[String] = getClaim(idToken)

    for {
      userId <- getUserId(idp.commonDetails.platform, idToken)
      username <- idp.commonDetails.usernameClaim
        .filter(_.nonEmpty)
        .map(c =>
          claim(c).toRight(InvalidJWT(s"Missing the configured username claim $c in the ID token"))
        )
        .getOrElse(Right(userId))
      user = new DefaultUserBean(
        userId,
        username,
        claim(OpenIDConnectParams.GIVEN_NAME).getOrElse(""),
        claim(OpenIDConnectParams.FAMILY_NAME).getOrElse(""),
        claim(OpenIDConnectParams.EMAIL).orNull
      )
      // Confirm the OEQ roles
      oeqRoles <- roleMapping(idp, idToken)
      // Setup the user state and log the user in
      userState = new DefaultUserState
      _ <- Either
        .catchNonFatal {
          userState.getUsersRoles.addAll(oeqRoles)
          userState.setLoggedInUser(user)
          userService.setupUserState(userState, wad, true)
        }
        .leftMap(error => ServerError(s"Failed to setup user state: ${error.getMessage}"))
    } yield userService.login(userState, true)
  }

  /** Confirm User ID from the ID token.
    *
    * For Entra ID, According to the their claim reference, claim 'oid' is the unique identifier for
    * the user across applications.
    *
    * For other platforms, use claim 'sub' as the unique identifier.
    *
    * Reference:
    *   - https://learn.microsoft.com/en-us/entra/identity-platform/id-token-claims-reference
    */
  private def getUserId(
      platform: IdentityProviderPlatform.Value,
      token: DecodedJWT
  ): Either[InvalidJWT, String] = platform match {
    case IdentityProviderPlatform.ENTRA_ID => getRequiredClaim(token, "oid")
    case _                                 => Right(token.getSubject)
  }

  // If there is a role configuration, use the configured role claim and role mappings to determine the OEQ roles.
  // Missing the role claim in the token or having an unexpected role claim format will result in an error of
  // InvalidJWT. If there isn't a role configuration, use the default roles instead.
  private def roleMapping(
      idp: IdentityProviderDetails,
      token: DecodedJWT
  ): Either[InvalidJWT, java.util.Collection[String]] = {
    // Return a function that takes an IDP role and returns a set of OEQ roles based on the role mappings.
    def getOeqRolesFromMappings(mappings: Map[String, Set[String]]): String => Set[String] =
      (idpRole: String) => mappings.getOrElse(idpRole, Set.empty)

    idp.commonDetails.roleConfig
      .map { case RoleConfiguration(roleClaim, mappings) =>
        getClaimAsSet(token, roleClaim) match {
          case Some(idpRoles) => Right(idpRoles.flatMap(getOeqRolesFromMappings(mappings)))
          case None =>
            Left(
              InvalidJWT(
                s"Missing the configured role claim $roleClaim in the ID token, or the claim is not in the format of array."
              )
            )
        }
      }
      .getOrElse(Right(idp.commonDetails.defaultRoles))
      .map(_.asJavaCollection)
  }

  /** Handle the potential errors returned from the IdP token endpoint, and sttp groups the errors
    * into two categories: `DeserializationError` and `HttpError`. Depending on the received error
    * type, return either an instance of [[GeneralError]] or [[TokenError]].
    */
  private def handleTokenError(error: ResponseError[Error]): OAuth2Error = error match {
    case DeserializationError(_, error) =>
      ServerError(
        s"An ID Token has been issued but can't be retrieved from an unexpected response format: ${error.getMessage}"
      )
    // For general HTTP client errors, the error structure should follow the OAuth2 spec as defined in `TokenErrorResponse`.
    case HttpError(body, status) if status.isClientError =>
      parse(body)
        .flatMap(_.as[TokenErrorResponse])
        .fold(
          _ => {
            LOGGER.error(s"Failed to request an ID token. Received response: $body")
            ServerError(
              "Failed to request an ID token, but the error is unknown due to unexpected response format."
            )
          },
          resp => {
            val msg = resp.error_description.getOrElse(NO_FURTHER_INFO)
            status.code match {
              case 400 => TokenError(resp.error, msg)
              case 401 => NotAuthorized(msg)
              case 403 => AccessDenied(msg)
              case _   => ServerError(msg)
            }
          }
        )
    case HttpError(body, status) if status.isServerError =>
      ServerError(s"Failed to request an ID token: $body")
  }

  private def redirectUri = s"${CurrentInstitution.get().getUrl}oidc/callback"
}
